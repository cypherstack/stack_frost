/* 
 * This file is part of Stack Wallet.
 * 
 * Copyright (c) 2023 Cypher Stack
 * All Rights Reserved.
 * The code is distributed under GPLv3 license, see LICENSE file for details.
 * Generated by Cypher Stack on 2023-05-26
 *
 */

import 'package:flutter/material.dart';
import 'package:lottie/lottie.dart';
import 'package:stackfrost/themes/stack_colors.dart';
import 'package:stackfrost/utilities/assets.dart';

class RotatingArrowsController {
  VoidCallback? forward;
  VoidCallback? repeat;
  VoidCallback? stop;

  bool hasLoadedAnimation = false;
}

class RotatingArrows extends StatefulWidget {
  const RotatingArrows({
    Key? key,
    required this.height,
    required this.width,
    this.controller,
    this.color,
    this.spinByDefault = true,
  }) : super(key: key);

  final double height;
  final double width;
  final RotatingArrowsController? controller;
  final Color? color;
  final bool spinByDefault;

  @override
  State<RotatingArrows> createState() => _RotatingArrowsState();
}

class _RotatingArrowsState extends State<RotatingArrows>
    with SingleTickerProviderStateMixin {
  late final AnimationController animationController;

  @override
  void initState() {
    animationController = AnimationController(vsync: this);

    widget.controller?.forward = animationController.forward;
    widget.controller?.repeat = animationController.repeat;
    widget.controller?.stop = animationController.stop;

    super.initState();
  }

  @override
  void dispose() {
    animationController.dispose();
    widget.controller?.forward = null;
    widget.controller?.repeat = null;
    widget.controller?.stop = null;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Lottie.asset(
      Assets.lottie.arrowRotate,
      controller: animationController,
      height: widget.height,
      width: widget.width,
      delegates: LottieDelegates(
        values: [
          ValueDelegate.color(
            const ["**"],
            value: widget.color ??
                Theme.of(context).extension<StackColors>()!.accentColorDark,
          ),
          ValueDelegate.strokeColor(
            const ["**"],
            value: widget.color ??
                Theme.of(context).extension<StackColors>()!.accentColorDark,
          ),
        ],
      ),
      onLoaded: (composition) {
        animationController.duration = composition.duration;
        widget.controller?.hasLoadedAnimation = true;

        // if controller was not set just assume continuous repeat
        if (widget.spinByDefault) {
          animationController.repeat();
        }
      },
    );
  }
}
